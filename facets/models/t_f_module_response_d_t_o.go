// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TFModuleResponseDTO t f module response d t o
//
// swagger:model TFModuleResponseDTO
type TFModuleResponseDTO struct {

	// Alias flavors for the module
	// Example: ["medium","extra-large"]
	// Unique: true
	AliasFlavors []string `json:"aliasFlavors"`

	// List of test projects where this module will be available. If absent, it is available globally.
	AllowedTestProjects []string `json:"allowedTestProjects"`

	// Supported cloud providers
	// Example: ["aws","azure"]
	// Unique: true
	Clouds []string `json:"clouds"`

	// created by
	CreatedBy string `json:"createdBy,omitempty"`

	// creation date
	// Format: date-time
	CreationDate strfmt.DateTime `json:"creationDate,omitempty"`

	// Module description
	Description string `json:"description,omitempty"`

	// feature branch
	FeatureBranch bool `json:"featureBranch,omitempty"`

	// Flavor of the TF Module
	// Example: small
	Flavor string `json:"flavor,omitempty"`

	// Reference to a specific GIT branch or commit
	// Example: develop
	GitRef string `json:"gitRef,omitempty"`

	// URL of the GIT repository
	// Example: https://gitlab.com/repo.git
	GitURL string `json:"gitUrl,omitempty"`

	// iac tool
	// Unique: true
	IacTool []string `json:"iacTool"`

	// id
	ID string `json:"id,omitempty"`

	// Input parameters for this module
	Inputs map[string]Input `json:"inputs,omitempty"`

	// Intent of the TF Module
	// Example: compute
	Intent string `json:"intent,omitempty"`

	// intent details
	IntentDetails *IntentResponseDTO `json:"intentDetails,omitempty"`

	// last modified by
	LastModifiedBy string `json:"lastModifiedBy,omitempty"`

	// last modified date
	// Format: date-time
	LastModifiedDate strfmt.DateTime `json:"lastModifiedDate,omitempty"`

	// latest version
	LatestVersion *OtherVersion `json:"latestVersion,omitempty"`

	// Metadata of the module
	Metadata string `json:"metadata,omitempty"`

	// Maximum allowed length for resource names using this module
	// Example: 40
	NameLengthLimit int32 `json:"nameLengthLimit,omitempty"`

	// other versions
	// Unique: true
	OtherVersions []*OtherVersion `json:"otherVersions"`

	// outputs
	Outputs []*IntentOutput `json:"outputs"`

	// preview module Id
	PreviewModuleID string `json:"previewModuleId,omitempty"`

	// published module Id
	PublishedModuleID string `json:"publishedModuleId,omitempty"`

	// Readme content in markdown format
	ReadmeMd string `json:"readmeMd,omitempty"`

	// Sample JSON configuration
	// Example: {}
	SampleJSON string `json:"sampleJson,omitempty"`

	// Source of the TF Module
	// Enum: ["BUILT_IN","CUSTOM"]
	Source string `json:"source,omitempty"`

	// Specification details of the module
	Spec string `json:"spec,omitempty"`

	// Stage of the TF Module in its lifecycle
	// Example: PUBLISHED
	// Enum: ["PREVIEW","PUBLISHED"]
	Stage string `json:"stage,omitempty"`

	// Tags associated with the module
	// Example: ["tag1","tag2"]
	// Unique: true
	Tags []string `json:"tags"`

	// Type of the TF Module
	// Example: SIMPLE
	// Enum: ["SIMPLE","ADD_ON"]
	Type string `json:"type,omitempty"`

	// Version of the TF Module
	// Example: 1.0.0
	Version string `json:"version,omitempty"`

	// versioning key
	VersioningKey string `json:"versioningKey,omitempty"`
}

// Validate validates this t f module response d t o
func (m *TFModuleResponseDTO) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAliasFlavors(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClouds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIacTool(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInputs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIntentDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastModifiedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatestVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOtherVersions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOutputs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TFModuleResponseDTO) validateAliasFlavors(formats strfmt.Registry) error {
	if swag.IsZero(m.AliasFlavors) { // not required
		return nil
	}

	if err := validate.UniqueItems("aliasFlavors", "body", m.AliasFlavors); err != nil {
		return err
	}

	return nil
}

func (m *TFModuleResponseDTO) validateClouds(formats strfmt.Registry) error {
	if swag.IsZero(m.Clouds) { // not required
		return nil
	}

	if err := validate.UniqueItems("clouds", "body", m.Clouds); err != nil {
		return err
	}

	return nil
}

func (m *TFModuleResponseDTO) validateCreationDate(formats strfmt.Registry) error {
	if swag.IsZero(m.CreationDate) { // not required
		return nil
	}

	if err := validate.FormatOf("creationDate", "body", "date-time", m.CreationDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var tFModuleResponseDTOIacToolItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TERRAFORM","OPENTOFU"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		tFModuleResponseDTOIacToolItemsEnum = append(tFModuleResponseDTOIacToolItemsEnum, v)
	}
}

func (m *TFModuleResponseDTO) validateIacToolItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, tFModuleResponseDTOIacToolItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TFModuleResponseDTO) validateIacTool(formats strfmt.Registry) error {
	if swag.IsZero(m.IacTool) { // not required
		return nil
	}

	if err := validate.UniqueItems("iacTool", "body", m.IacTool); err != nil {
		return err
	}

	for i := 0; i < len(m.IacTool); i++ {

		// value enum
		if err := m.validateIacToolItemsEnum("iacTool"+"."+strconv.Itoa(i), "body", m.IacTool[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *TFModuleResponseDTO) validateInputs(formats strfmt.Registry) error {
	if swag.IsZero(m.Inputs) { // not required
		return nil
	}

	for k := range m.Inputs {

		if err := validate.Required("inputs"+"."+k, "body", m.Inputs[k]); err != nil {
			return err
		}
		if val, ok := m.Inputs[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("inputs" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("inputs" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *TFModuleResponseDTO) validateIntentDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.IntentDetails) { // not required
		return nil
	}

	if m.IntentDetails != nil {
		if err := m.IntentDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("intentDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("intentDetails")
			}
			return err
		}
	}

	return nil
}

func (m *TFModuleResponseDTO) validateLastModifiedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.LastModifiedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("lastModifiedDate", "body", "date-time", m.LastModifiedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TFModuleResponseDTO) validateLatestVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.LatestVersion) { // not required
		return nil
	}

	if m.LatestVersion != nil {
		if err := m.LatestVersion.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("latestVersion")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("latestVersion")
			}
			return err
		}
	}

	return nil
}

func (m *TFModuleResponseDTO) validateOtherVersions(formats strfmt.Registry) error {
	if swag.IsZero(m.OtherVersions) { // not required
		return nil
	}

	if err := validate.UniqueItems("otherVersions", "body", m.OtherVersions); err != nil {
		return err
	}

	for i := 0; i < len(m.OtherVersions); i++ {
		if swag.IsZero(m.OtherVersions[i]) { // not required
			continue
		}

		if m.OtherVersions[i] != nil {
			if err := m.OtherVersions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("otherVersions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("otherVersions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TFModuleResponseDTO) validateOutputs(formats strfmt.Registry) error {
	if swag.IsZero(m.Outputs) { // not required
		return nil
	}

	for i := 0; i < len(m.Outputs); i++ {
		if swag.IsZero(m.Outputs[i]) { // not required
			continue
		}

		if m.Outputs[i] != nil {
			if err := m.Outputs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("outputs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("outputs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var tFModuleResponseDTOTypeSourcePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BUILT_IN","CUSTOM"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		tFModuleResponseDTOTypeSourcePropEnum = append(tFModuleResponseDTOTypeSourcePropEnum, v)
	}
}

const (

	// TFModuleResponseDTOSourceBUILTIN captures enum value "BUILT_IN"
	TFModuleResponseDTOSourceBUILTIN string = "BUILT_IN"

	// TFModuleResponseDTOSourceCUSTOM captures enum value "CUSTOM"
	TFModuleResponseDTOSourceCUSTOM string = "CUSTOM"
)

// prop value enum
func (m *TFModuleResponseDTO) validateSourceEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, tFModuleResponseDTOTypeSourcePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TFModuleResponseDTO) validateSource(formats strfmt.Registry) error {
	if swag.IsZero(m.Source) { // not required
		return nil
	}

	// value enum
	if err := m.validateSourceEnum("source", "body", m.Source); err != nil {
		return err
	}

	return nil
}

var tFModuleResponseDTOTypeStagePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PREVIEW","PUBLISHED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		tFModuleResponseDTOTypeStagePropEnum = append(tFModuleResponseDTOTypeStagePropEnum, v)
	}
}

const (

	// TFModuleResponseDTOStagePREVIEW captures enum value "PREVIEW"
	TFModuleResponseDTOStagePREVIEW string = "PREVIEW"

	// TFModuleResponseDTOStagePUBLISHED captures enum value "PUBLISHED"
	TFModuleResponseDTOStagePUBLISHED string = "PUBLISHED"
)

// prop value enum
func (m *TFModuleResponseDTO) validateStageEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, tFModuleResponseDTOTypeStagePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TFModuleResponseDTO) validateStage(formats strfmt.Registry) error {
	if swag.IsZero(m.Stage) { // not required
		return nil
	}

	// value enum
	if err := m.validateStageEnum("stage", "body", m.Stage); err != nil {
		return err
	}

	return nil
}

func (m *TFModuleResponseDTO) validateTags(formats strfmt.Registry) error {
	if swag.IsZero(m.Tags) { // not required
		return nil
	}

	if err := validate.UniqueItems("tags", "body", m.Tags); err != nil {
		return err
	}

	return nil
}

var tFModuleResponseDTOTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SIMPLE","ADD_ON"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		tFModuleResponseDTOTypeTypePropEnum = append(tFModuleResponseDTOTypeTypePropEnum, v)
	}
}

const (

	// TFModuleResponseDTOTypeSIMPLE captures enum value "SIMPLE"
	TFModuleResponseDTOTypeSIMPLE string = "SIMPLE"

	// TFModuleResponseDTOTypeADDON captures enum value "ADD_ON"
	TFModuleResponseDTOTypeADDON string = "ADD_ON"
)

// prop value enum
func (m *TFModuleResponseDTO) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, tFModuleResponseDTOTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TFModuleResponseDTO) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this t f module response d t o based on the context it is used
func (m *TFModuleResponseDTO) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateInputs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIntentDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatestVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOtherVersions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOutputs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TFModuleResponseDTO) contextValidateInputs(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.Inputs {

		if val, ok := m.Inputs[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *TFModuleResponseDTO) contextValidateIntentDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.IntentDetails != nil {

		if swag.IsZero(m.IntentDetails) { // not required
			return nil
		}

		if err := m.IntentDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("intentDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("intentDetails")
			}
			return err
		}
	}

	return nil
}

func (m *TFModuleResponseDTO) contextValidateLatestVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.LatestVersion != nil {

		if swag.IsZero(m.LatestVersion) { // not required
			return nil
		}

		if err := m.LatestVersion.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("latestVersion")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("latestVersion")
			}
			return err
		}
	}

	return nil
}

func (m *TFModuleResponseDTO) contextValidateOtherVersions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.OtherVersions); i++ {

		if m.OtherVersions[i] != nil {

			if swag.IsZero(m.OtherVersions[i]) { // not required
				return nil
			}

			if err := m.OtherVersions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("otherVersions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("otherVersions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TFModuleResponseDTO) contextValidateOutputs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Outputs); i++ {

		if m.Outputs[i] != nil {

			if swag.IsZero(m.Outputs[i]) { // not required
				return nil
			}

			if err := m.Outputs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("outputs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("outputs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TFModuleResponseDTO) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TFModuleResponseDTO) UnmarshalBinary(b []byte) error {
	var res TFModuleResponseDTO
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
