// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// EnvironmentConfiguration EnvironmentConfiguration
//
// swagger:model EnvironmentConfiguration
type EnvironmentConfiguration struct {

	// cluster autoscaler configuration
	ClusterAutoscalerConfiguration *ClusterAutoscalerConfiguration `json:"clusterAutoscalerConfiguration,omitempty"`

	// common configs
	CommonConfigs map[string]string `json:"commonConfigs,omitempty"`

	// common credentials
	CommonCredentials map[string]string `json:"commonCredentials,omitempty"`

	// ecr mirror repo
	EcrMirrorRepo string `json:"ecrMirrorRepo,omitempty"`

	// filebeat enabled
	FilebeatEnabled bool `json:"filebeatEnabled,omitempty"`

	// jmx side car enabled
	JmxSideCarEnabled bool `json:"jmxSideCarEnabled,omitempty"`

	// k8s logging configuration
	K8sLoggingConfiguration *K8sLoggingConfiguration `json:"k8sLoggingConfiguration,omitempty"`

	// kube2 iam configuration
	Kube2IamConfiguration *Kube2IamConfiguration `json:"kube2IamConfiguration,omitempty"`

	// kubernetes Api endpoint
	KubernetesAPIEndpoint string `json:"kubernetesApiEndpoint,omitempty"`

	// kubernetes token
	KubernetesToken string `json:"kubernetesToken,omitempty"`

	// metric server enabled
	MetricServerEnabled bool `json:"metricServerEnabled,omitempty"`

	// new relic cluster name
	NewRelicClusterName string `json:"newRelicClusterName,omitempty"`

	// node group
	NodeGroup string `json:"nodeGroup,omitempty"`

	// pre deploy task enabled
	PreDeployTaskEnabled bool `json:"preDeployTaskEnabled,omitempty"`

	// private Dns configuration
	PrivateDNSConfiguration *ExternalDNSConfiguration `json:"privateDnsConfiguration,omitempty"`

	// public Dns configuration
	PublicDNSConfiguration *ExternalDNSConfiguration `json:"publicDnsConfiguration,omitempty"`

	// requests to limits ratio
	RequestsToLimitsRatio float64 `json:"requestsToLimitsRatio,omitempty"`

	// resource allocation strategy definition
	ResourceAllocationStrategyDefinition map[string]float64 `json:"resourceAllocationStrategyDefinition,omitempty"`

	// s3 dump aws config
	S3DumpAwsConfig *S3DumpAwsConfig `json:"s3DumpAwsConfig,omitempty"`

	// spot termination handling enabled
	SpotTerminationHandlingEnabled bool `json:"spotTerminationHandlingEnabled,omitempty"`

	// ssl configs
	SslConfigs *SSLConfigs `json:"sslConfigs,omitempty"`
}

// Validate validates this environment configuration
func (m *EnvironmentConfiguration) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClusterAutoscalerConfiguration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateK8sLoggingConfiguration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKube2IamConfiguration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrivateDNSConfiguration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePublicDNSConfiguration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateS3DumpAwsConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSslConfigs(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EnvironmentConfiguration) validateClusterAutoscalerConfiguration(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterAutoscalerConfiguration) { // not required
		return nil
	}

	if m.ClusterAutoscalerConfiguration != nil {
		if err := m.ClusterAutoscalerConfiguration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clusterAutoscalerConfiguration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("clusterAutoscalerConfiguration")
			}
			return err
		}
	}

	return nil
}

func (m *EnvironmentConfiguration) validateK8sLoggingConfiguration(formats strfmt.Registry) error {
	if swag.IsZero(m.K8sLoggingConfiguration) { // not required
		return nil
	}

	if m.K8sLoggingConfiguration != nil {
		if err := m.K8sLoggingConfiguration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("k8sLoggingConfiguration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("k8sLoggingConfiguration")
			}
			return err
		}
	}

	return nil
}

func (m *EnvironmentConfiguration) validateKube2IamConfiguration(formats strfmt.Registry) error {
	if swag.IsZero(m.Kube2IamConfiguration) { // not required
		return nil
	}

	if m.Kube2IamConfiguration != nil {
		if err := m.Kube2IamConfiguration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("kube2IamConfiguration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("kube2IamConfiguration")
			}
			return err
		}
	}

	return nil
}

func (m *EnvironmentConfiguration) validatePrivateDNSConfiguration(formats strfmt.Registry) error {
	if swag.IsZero(m.PrivateDNSConfiguration) { // not required
		return nil
	}

	if m.PrivateDNSConfiguration != nil {
		if err := m.PrivateDNSConfiguration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("privateDnsConfiguration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("privateDnsConfiguration")
			}
			return err
		}
	}

	return nil
}

func (m *EnvironmentConfiguration) validatePublicDNSConfiguration(formats strfmt.Registry) error {
	if swag.IsZero(m.PublicDNSConfiguration) { // not required
		return nil
	}

	if m.PublicDNSConfiguration != nil {
		if err := m.PublicDNSConfiguration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("publicDnsConfiguration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("publicDnsConfiguration")
			}
			return err
		}
	}

	return nil
}

func (m *EnvironmentConfiguration) validateS3DumpAwsConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.S3DumpAwsConfig) { // not required
		return nil
	}

	if m.S3DumpAwsConfig != nil {
		if err := m.S3DumpAwsConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3DumpAwsConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("s3DumpAwsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *EnvironmentConfiguration) validateSslConfigs(formats strfmt.Registry) error {
	if swag.IsZero(m.SslConfigs) { // not required
		return nil
	}

	if m.SslConfigs != nil {
		if err := m.SslConfigs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sslConfigs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sslConfigs")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this environment configuration based on the context it is used
func (m *EnvironmentConfiguration) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateClusterAutoscalerConfiguration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateK8sLoggingConfiguration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateKube2IamConfiguration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrivateDNSConfiguration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePublicDNSConfiguration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateS3DumpAwsConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSslConfigs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EnvironmentConfiguration) contextValidateClusterAutoscalerConfiguration(ctx context.Context, formats strfmt.Registry) error {

	if m.ClusterAutoscalerConfiguration != nil {

		if swag.IsZero(m.ClusterAutoscalerConfiguration) { // not required
			return nil
		}

		if err := m.ClusterAutoscalerConfiguration.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clusterAutoscalerConfiguration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("clusterAutoscalerConfiguration")
			}
			return err
		}
	}

	return nil
}

func (m *EnvironmentConfiguration) contextValidateK8sLoggingConfiguration(ctx context.Context, formats strfmt.Registry) error {

	if m.K8sLoggingConfiguration != nil {

		if swag.IsZero(m.K8sLoggingConfiguration) { // not required
			return nil
		}

		if err := m.K8sLoggingConfiguration.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("k8sLoggingConfiguration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("k8sLoggingConfiguration")
			}
			return err
		}
	}

	return nil
}

func (m *EnvironmentConfiguration) contextValidateKube2IamConfiguration(ctx context.Context, formats strfmt.Registry) error {

	if m.Kube2IamConfiguration != nil {

		if swag.IsZero(m.Kube2IamConfiguration) { // not required
			return nil
		}

		if err := m.Kube2IamConfiguration.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("kube2IamConfiguration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("kube2IamConfiguration")
			}
			return err
		}
	}

	return nil
}

func (m *EnvironmentConfiguration) contextValidatePrivateDNSConfiguration(ctx context.Context, formats strfmt.Registry) error {

	if m.PrivateDNSConfiguration != nil {

		if swag.IsZero(m.PrivateDNSConfiguration) { // not required
			return nil
		}

		if err := m.PrivateDNSConfiguration.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("privateDnsConfiguration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("privateDnsConfiguration")
			}
			return err
		}
	}

	return nil
}

func (m *EnvironmentConfiguration) contextValidatePublicDNSConfiguration(ctx context.Context, formats strfmt.Registry) error {

	if m.PublicDNSConfiguration != nil {

		if swag.IsZero(m.PublicDNSConfiguration) { // not required
			return nil
		}

		if err := m.PublicDNSConfiguration.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("publicDnsConfiguration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("publicDnsConfiguration")
			}
			return err
		}
	}

	return nil
}

func (m *EnvironmentConfiguration) contextValidateS3DumpAwsConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.S3DumpAwsConfig != nil {

		if swag.IsZero(m.S3DumpAwsConfig) { // not required
			return nil
		}

		if err := m.S3DumpAwsConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3DumpAwsConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("s3DumpAwsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *EnvironmentConfiguration) contextValidateSslConfigs(ctx context.Context, formats strfmt.Registry) error {

	if m.SslConfigs != nil {

		if swag.IsZero(m.SslConfigs) { // not required
			return nil
		}

		if err := m.SslConfigs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sslConfigs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sslConfigs")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EnvironmentConfiguration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EnvironmentConfiguration) UnmarshalBinary(b []byte) error {
	var res EnvironmentConfiguration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
