// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PodSpec pod spec
//
// swagger:model PodSpec
type PodSpec struct {

	// active deadline seconds
	ActiveDeadlineSeconds int64 `json:"activeDeadlineSeconds,omitempty"`

	// affinity
	Affinity *Affinity `json:"affinity,omitempty"`

	// automount service account token
	AutomountServiceAccountToken bool `json:"automountServiceAccountToken,omitempty"`

	// containers
	Containers []*Container `json:"containers"`

	// dns config
	DNSConfig *PodDNSConfig `json:"dnsConfig,omitempty"`

	// dns policy
	DNSPolicy string `json:"dnsPolicy,omitempty"`

	// enable service links
	EnableServiceLinks bool `json:"enableServiceLinks,omitempty"`

	// ephemeral containers
	EphemeralContainers []*EphemeralContainer `json:"ephemeralContainers"`

	// host aliases
	HostAliases []*HostAlias `json:"hostAliases"`

	// host IP c
	HostIPC bool `json:"hostIPC,omitempty"`

	// host network
	HostNetwork bool `json:"hostNetwork,omitempty"`

	// host p ID
	HostPID bool `json:"hostPID,omitempty"`

	// host users
	HostUsers bool `json:"hostUsers,omitempty"`

	// hostname
	Hostname string `json:"hostname,omitempty"`

	// image pull secrets
	ImagePullSecrets []*LocalObjectReference `json:"imagePullSecrets"`

	// init containers
	InitContainers []*Container `json:"initContainers"`

	// node name
	NodeName string `json:"nodeName,omitempty"`

	// node selector
	NodeSelector map[string]string `json:"nodeSelector,omitempty"`

	// os
	Os *PodOS `json:"os,omitempty"`

	// overhead
	Overhead map[string]Quantity `json:"overhead,omitempty"`

	// preemption policy
	PreemptionPolicy string `json:"preemptionPolicy,omitempty"`

	// priority
	Priority int32 `json:"priority,omitempty"`

	// priority class name
	PriorityClassName string `json:"priorityClassName,omitempty"`

	// readiness gates
	ReadinessGates []*PodReadinessGate `json:"readinessGates"`

	// resource claims
	ResourceClaims []*PodResourceClaim `json:"resourceClaims"`

	// restart policy
	RestartPolicy string `json:"restartPolicy,omitempty"`

	// runtime class name
	RuntimeClassName string `json:"runtimeClassName,omitempty"`

	// scheduler name
	SchedulerName string `json:"schedulerName,omitempty"`

	// scheduling gates
	SchedulingGates []*PodSchedulingGate `json:"schedulingGates"`

	// security context
	SecurityContext *PodSecurityContext `json:"securityContext,omitempty"`

	// service account
	ServiceAccount string `json:"serviceAccount,omitempty"`

	// service account name
	ServiceAccountName string `json:"serviceAccountName,omitempty"`

	// set hostname as f q d n
	SetHostnameAsFQDN bool `json:"setHostnameAsFQDN,omitempty"`

	// share process namespace
	ShareProcessNamespace bool `json:"shareProcessNamespace,omitempty"`

	// subdomain
	Subdomain string `json:"subdomain,omitempty"`

	// termination grace period seconds
	TerminationGracePeriodSeconds int64 `json:"terminationGracePeriodSeconds,omitempty"`

	// tolerations
	Tolerations []*Toleration `json:"tolerations"`

	// topology spread constraints
	TopologySpreadConstraints []*TopologySpreadConstraint `json:"topologySpreadConstraints"`

	// volumes
	Volumes []*Volume `json:"volumes"`
}

// Validate validates this pod spec
func (m *PodSpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAffinity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContainers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDNSConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEphemeralContainers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHostAliases(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImagePullSecrets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInitContainers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOverhead(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReadinessGates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResourceClaims(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchedulingGates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecurityContext(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTolerations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTopologySpreadConstraints(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PodSpec) validateAffinity(formats strfmt.Registry) error {
	if swag.IsZero(m.Affinity) { // not required
		return nil
	}

	if m.Affinity != nil {
		if err := m.Affinity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("affinity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("affinity")
			}
			return err
		}
	}

	return nil
}

func (m *PodSpec) validateContainers(formats strfmt.Registry) error {
	if swag.IsZero(m.Containers) { // not required
		return nil
	}

	for i := 0; i < len(m.Containers); i++ {
		if swag.IsZero(m.Containers[i]) { // not required
			continue
		}

		if m.Containers[i] != nil {
			if err := m.Containers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("containers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("containers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) validateDNSConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.DNSConfig) { // not required
		return nil
	}

	if m.DNSConfig != nil {
		if err := m.DNSConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dnsConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dnsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *PodSpec) validateEphemeralContainers(formats strfmt.Registry) error {
	if swag.IsZero(m.EphemeralContainers) { // not required
		return nil
	}

	for i := 0; i < len(m.EphemeralContainers); i++ {
		if swag.IsZero(m.EphemeralContainers[i]) { // not required
			continue
		}

		if m.EphemeralContainers[i] != nil {
			if err := m.EphemeralContainers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ephemeralContainers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ephemeralContainers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) validateHostAliases(formats strfmt.Registry) error {
	if swag.IsZero(m.HostAliases) { // not required
		return nil
	}

	for i := 0; i < len(m.HostAliases); i++ {
		if swag.IsZero(m.HostAliases[i]) { // not required
			continue
		}

		if m.HostAliases[i] != nil {
			if err := m.HostAliases[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("hostAliases" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("hostAliases" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) validateImagePullSecrets(formats strfmt.Registry) error {
	if swag.IsZero(m.ImagePullSecrets) { // not required
		return nil
	}

	for i := 0; i < len(m.ImagePullSecrets); i++ {
		if swag.IsZero(m.ImagePullSecrets[i]) { // not required
			continue
		}

		if m.ImagePullSecrets[i] != nil {
			if err := m.ImagePullSecrets[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("imagePullSecrets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("imagePullSecrets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) validateInitContainers(formats strfmt.Registry) error {
	if swag.IsZero(m.InitContainers) { // not required
		return nil
	}

	for i := 0; i < len(m.InitContainers); i++ {
		if swag.IsZero(m.InitContainers[i]) { // not required
			continue
		}

		if m.InitContainers[i] != nil {
			if err := m.InitContainers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("initContainers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("initContainers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) validateOs(formats strfmt.Registry) error {
	if swag.IsZero(m.Os) { // not required
		return nil
	}

	if m.Os != nil {
		if err := m.Os.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("os")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("os")
			}
			return err
		}
	}

	return nil
}

func (m *PodSpec) validateOverhead(formats strfmt.Registry) error {
	if swag.IsZero(m.Overhead) { // not required
		return nil
	}

	for k := range m.Overhead {

		if err := validate.Required("overhead"+"."+k, "body", m.Overhead[k]); err != nil {
			return err
		}
		if val, ok := m.Overhead[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("overhead" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("overhead" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) validateReadinessGates(formats strfmt.Registry) error {
	if swag.IsZero(m.ReadinessGates) { // not required
		return nil
	}

	for i := 0; i < len(m.ReadinessGates); i++ {
		if swag.IsZero(m.ReadinessGates[i]) { // not required
			continue
		}

		if m.ReadinessGates[i] != nil {
			if err := m.ReadinessGates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("readinessGates" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("readinessGates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) validateResourceClaims(formats strfmt.Registry) error {
	if swag.IsZero(m.ResourceClaims) { // not required
		return nil
	}

	for i := 0; i < len(m.ResourceClaims); i++ {
		if swag.IsZero(m.ResourceClaims[i]) { // not required
			continue
		}

		if m.ResourceClaims[i] != nil {
			if err := m.ResourceClaims[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resourceClaims" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resourceClaims" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) validateSchedulingGates(formats strfmt.Registry) error {
	if swag.IsZero(m.SchedulingGates) { // not required
		return nil
	}

	for i := 0; i < len(m.SchedulingGates); i++ {
		if swag.IsZero(m.SchedulingGates[i]) { // not required
			continue
		}

		if m.SchedulingGates[i] != nil {
			if err := m.SchedulingGates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("schedulingGates" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("schedulingGates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) validateSecurityContext(formats strfmt.Registry) error {
	if swag.IsZero(m.SecurityContext) { // not required
		return nil
	}

	if m.SecurityContext != nil {
		if err := m.SecurityContext.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("securityContext")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("securityContext")
			}
			return err
		}
	}

	return nil
}

func (m *PodSpec) validateTolerations(formats strfmt.Registry) error {
	if swag.IsZero(m.Tolerations) { // not required
		return nil
	}

	for i := 0; i < len(m.Tolerations); i++ {
		if swag.IsZero(m.Tolerations[i]) { // not required
			continue
		}

		if m.Tolerations[i] != nil {
			if err := m.Tolerations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tolerations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tolerations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) validateTopologySpreadConstraints(formats strfmt.Registry) error {
	if swag.IsZero(m.TopologySpreadConstraints) { // not required
		return nil
	}

	for i := 0; i < len(m.TopologySpreadConstraints); i++ {
		if swag.IsZero(m.TopologySpreadConstraints[i]) { // not required
			continue
		}

		if m.TopologySpreadConstraints[i] != nil {
			if err := m.TopologySpreadConstraints[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("topologySpreadConstraints" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("topologySpreadConstraints" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) validateVolumes(formats strfmt.Registry) error {
	if swag.IsZero(m.Volumes) { // not required
		return nil
	}

	for i := 0; i < len(m.Volumes); i++ {
		if swag.IsZero(m.Volumes[i]) { // not required
			continue
		}

		if m.Volumes[i] != nil {
			if err := m.Volumes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this pod spec based on the context it is used
func (m *PodSpec) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAffinity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContainers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDNSConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEphemeralContainers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHostAliases(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateImagePullSecrets(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInitContainers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOverhead(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReadinessGates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResourceClaims(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSchedulingGates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecurityContext(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTolerations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTopologySpreadConstraints(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PodSpec) contextValidateAffinity(ctx context.Context, formats strfmt.Registry) error {

	if m.Affinity != nil {

		if swag.IsZero(m.Affinity) { // not required
			return nil
		}

		if err := m.Affinity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("affinity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("affinity")
			}
			return err
		}
	}

	return nil
}

func (m *PodSpec) contextValidateContainers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Containers); i++ {

		if m.Containers[i] != nil {

			if swag.IsZero(m.Containers[i]) { // not required
				return nil
			}

			if err := m.Containers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("containers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("containers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) contextValidateDNSConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.DNSConfig != nil {

		if swag.IsZero(m.DNSConfig) { // not required
			return nil
		}

		if err := m.DNSConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dnsConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dnsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *PodSpec) contextValidateEphemeralContainers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.EphemeralContainers); i++ {

		if m.EphemeralContainers[i] != nil {

			if swag.IsZero(m.EphemeralContainers[i]) { // not required
				return nil
			}

			if err := m.EphemeralContainers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ephemeralContainers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ephemeralContainers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) contextValidateHostAliases(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.HostAliases); i++ {

		if m.HostAliases[i] != nil {

			if swag.IsZero(m.HostAliases[i]) { // not required
				return nil
			}

			if err := m.HostAliases[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("hostAliases" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("hostAliases" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) contextValidateImagePullSecrets(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ImagePullSecrets); i++ {

		if m.ImagePullSecrets[i] != nil {

			if swag.IsZero(m.ImagePullSecrets[i]) { // not required
				return nil
			}

			if err := m.ImagePullSecrets[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("imagePullSecrets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("imagePullSecrets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) contextValidateInitContainers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.InitContainers); i++ {

		if m.InitContainers[i] != nil {

			if swag.IsZero(m.InitContainers[i]) { // not required
				return nil
			}

			if err := m.InitContainers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("initContainers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("initContainers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) contextValidateOs(ctx context.Context, formats strfmt.Registry) error {

	if m.Os != nil {

		if swag.IsZero(m.Os) { // not required
			return nil
		}

		if err := m.Os.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("os")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("os")
			}
			return err
		}
	}

	return nil
}

func (m *PodSpec) contextValidateOverhead(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.Overhead {

		if val, ok := m.Overhead[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) contextValidateReadinessGates(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ReadinessGates); i++ {

		if m.ReadinessGates[i] != nil {

			if swag.IsZero(m.ReadinessGates[i]) { // not required
				return nil
			}

			if err := m.ReadinessGates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("readinessGates" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("readinessGates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) contextValidateResourceClaims(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ResourceClaims); i++ {

		if m.ResourceClaims[i] != nil {

			if swag.IsZero(m.ResourceClaims[i]) { // not required
				return nil
			}

			if err := m.ResourceClaims[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resourceClaims" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resourceClaims" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) contextValidateSchedulingGates(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SchedulingGates); i++ {

		if m.SchedulingGates[i] != nil {

			if swag.IsZero(m.SchedulingGates[i]) { // not required
				return nil
			}

			if err := m.SchedulingGates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("schedulingGates" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("schedulingGates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) contextValidateSecurityContext(ctx context.Context, formats strfmt.Registry) error {

	if m.SecurityContext != nil {

		if swag.IsZero(m.SecurityContext) { // not required
			return nil
		}

		if err := m.SecurityContext.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("securityContext")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("securityContext")
			}
			return err
		}
	}

	return nil
}

func (m *PodSpec) contextValidateTolerations(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Tolerations); i++ {

		if m.Tolerations[i] != nil {

			if swag.IsZero(m.Tolerations[i]) { // not required
				return nil
			}

			if err := m.Tolerations[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tolerations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tolerations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) contextValidateTopologySpreadConstraints(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TopologySpreadConstraints); i++ {

		if m.TopologySpreadConstraints[i] != nil {

			if swag.IsZero(m.TopologySpreadConstraints[i]) { // not required
				return nil
			}

			if err := m.TopologySpreadConstraints[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("topologySpreadConstraints" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("topologySpreadConstraints" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PodSpec) contextValidateVolumes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Volumes); i++ {

		if m.Volumes[i] != nil {

			if swag.IsZero(m.Volumes[i]) { // not required
				return nil
			}

			if err := m.Volumes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PodSpec) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PodSpec) UnmarshalBinary(b []byte) error {
	var res PodSpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
