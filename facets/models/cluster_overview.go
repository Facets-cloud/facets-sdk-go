// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ClusterOverview cluster overview
//
// swagger:model ClusterOverview
type ClusterOverview struct {

	// base cluster
	BaseCluster *ClusterLite `json:"baseCluster,omitempty"`

	// cluster
	Cluster *AbstractCluster `json:"cluster,omitempty"`

	// cluster state
	// Enum: ["STOPPED","RUNNING","LAUNCHING","DESTROYING","LAUNCH_FAILED","DESTROY_FAILED","UNKNOWN","SCALE_DOWN","SCALING_DOWN","SCALE_DOWN_FAILED","SCALING_UP","SCALE_UP_FAILED"]
	ClusterState string `json:"clusterState,omitempty"`

	// id
	ID string `json:"id,omitempty"`

	// last release
	LastRelease *DeploymentLog `json:"lastRelease,omitempty"`

	// time to next release
	TimeToNextRelease string `json:"timeToNextRelease,omitempty"`
}

// Validate validates this cluster overview
func (m *ClusterOverview) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBaseCluster(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCluster(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastRelease(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterOverview) validateBaseCluster(formats strfmt.Registry) error {
	if swag.IsZero(m.BaseCluster) { // not required
		return nil
	}

	if m.BaseCluster != nil {
		if err := m.BaseCluster.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("baseCluster")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("baseCluster")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterOverview) validateCluster(formats strfmt.Registry) error {
	if swag.IsZero(m.Cluster) { // not required
		return nil
	}

	if m.Cluster != nil {
		if err := m.Cluster.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cluster")
			}
			return err
		}
	}

	return nil
}

var clusterOverviewTypeClusterStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["STOPPED","RUNNING","LAUNCHING","DESTROYING","LAUNCH_FAILED","DESTROY_FAILED","UNKNOWN","SCALE_DOWN","SCALING_DOWN","SCALE_DOWN_FAILED","SCALING_UP","SCALE_UP_FAILED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterOverviewTypeClusterStatePropEnum = append(clusterOverviewTypeClusterStatePropEnum, v)
	}
}

const (

	// ClusterOverviewClusterStateSTOPPED captures enum value "STOPPED"
	ClusterOverviewClusterStateSTOPPED string = "STOPPED"

	// ClusterOverviewClusterStateRUNNING captures enum value "RUNNING"
	ClusterOverviewClusterStateRUNNING string = "RUNNING"

	// ClusterOverviewClusterStateLAUNCHING captures enum value "LAUNCHING"
	ClusterOverviewClusterStateLAUNCHING string = "LAUNCHING"

	// ClusterOverviewClusterStateDESTROYING captures enum value "DESTROYING"
	ClusterOverviewClusterStateDESTROYING string = "DESTROYING"

	// ClusterOverviewClusterStateLAUNCHFAILED captures enum value "LAUNCH_FAILED"
	ClusterOverviewClusterStateLAUNCHFAILED string = "LAUNCH_FAILED"

	// ClusterOverviewClusterStateDESTROYFAILED captures enum value "DESTROY_FAILED"
	ClusterOverviewClusterStateDESTROYFAILED string = "DESTROY_FAILED"

	// ClusterOverviewClusterStateUNKNOWN captures enum value "UNKNOWN"
	ClusterOverviewClusterStateUNKNOWN string = "UNKNOWN"

	// ClusterOverviewClusterStateSCALEDOWN captures enum value "SCALE_DOWN"
	ClusterOverviewClusterStateSCALEDOWN string = "SCALE_DOWN"

	// ClusterOverviewClusterStateSCALINGDOWN captures enum value "SCALING_DOWN"
	ClusterOverviewClusterStateSCALINGDOWN string = "SCALING_DOWN"

	// ClusterOverviewClusterStateSCALEDOWNFAILED captures enum value "SCALE_DOWN_FAILED"
	ClusterOverviewClusterStateSCALEDOWNFAILED string = "SCALE_DOWN_FAILED"

	// ClusterOverviewClusterStateSCALINGUP captures enum value "SCALING_UP"
	ClusterOverviewClusterStateSCALINGUP string = "SCALING_UP"

	// ClusterOverviewClusterStateSCALEUPFAILED captures enum value "SCALE_UP_FAILED"
	ClusterOverviewClusterStateSCALEUPFAILED string = "SCALE_UP_FAILED"
)

// prop value enum
func (m *ClusterOverview) validateClusterStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterOverviewTypeClusterStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterOverview) validateClusterState(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterState) { // not required
		return nil
	}

	// value enum
	if err := m.validateClusterStateEnum("clusterState", "body", m.ClusterState); err != nil {
		return err
	}

	return nil
}

func (m *ClusterOverview) validateLastRelease(formats strfmt.Registry) error {
	if swag.IsZero(m.LastRelease) { // not required
		return nil
	}

	if m.LastRelease != nil {
		if err := m.LastRelease.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lastRelease")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("lastRelease")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster overview based on the context it is used
func (m *ClusterOverview) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBaseCluster(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCluster(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastRelease(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterOverview) contextValidateBaseCluster(ctx context.Context, formats strfmt.Registry) error {

	if m.BaseCluster != nil {

		if swag.IsZero(m.BaseCluster) { // not required
			return nil
		}

		if err := m.BaseCluster.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("baseCluster")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("baseCluster")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterOverview) contextValidateCluster(ctx context.Context, formats strfmt.Registry) error {

	if m.Cluster != nil {

		if swag.IsZero(m.Cluster) { // not required
			return nil
		}

		if err := m.Cluster.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cluster")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cluster")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterOverview) contextValidateLastRelease(ctx context.Context, formats strfmt.Registry) error {

	if m.LastRelease != nil {

		if swag.IsZero(m.LastRelease) { // not required
			return nil
		}

		if err := m.LastRelease.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lastRelease")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("lastRelease")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterOverview) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterOverview) UnmarshalBinary(b []byte) error {
	var res ClusterOverview
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
